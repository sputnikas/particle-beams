#include <iostream>
#include <vector>

#include "vec3.h"

const double EQ = 1.6021892E-19;
const double EM = 9.109534E-31;
const double EPS0 = 8.854187817E-12;
const double K0 = 8.987551788E9;
const double CL = 2.99792458E8;
const double RL = 2.8179402894E-15;
const double CL2 = 8.9875517873681764E16;

//////////////////////////////////////////////////////////////////////////////
// Particle
// После долгих размышлений появилась одна идея:
//      частицы, должны быть упорядочены во временной массив!
// 
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// ParticleData
// хранит информацию о положении частицы скоростях и ускорении
// здесь снова находится краегульный камень
// дело в том, что если рассматривать частицы, как нечто обобщённое,
// то они бывают различными:
//      по скорости и характеру взаимодействия:
//          - нерелятивистские
//          - релятивисткие
//      по типу распределения заряда, массы, формы и соответственно поля их окружающего:
//          - с простой симметрией (r, v, a) и всё
//              - точечные
//              - шаровые
//              - сферические
//          - с более сложной симметрией (появляются дополнительные степени свободы, как углы Эйлера или сложнее)
//              - точечные диполи
//              - точечные квадруполи ...
//              - кольца
//              - диски
//              - стержни
//          - с дополнительными необычными степенями свободы:
//              - частицы переменной массы (они ж крупные, могут и разделиться при столкновении!)
// и как учитывать всё это многообразие непонятно...
// а ведь ещё и можно задачу решать как в переменных (r, v, a), так и в переменных (r, p, F)!
// и в данном месте я окончательно выпадаю в осадок:
//      чтобы сделать такую абстракцию, которую потом легко расширить, изменить - нужно быть гением c++
//      единственный вариант, который я пока вижу для данной задачи - это использование специализированных шаблонов
//      и да мне такая сложность не нравится
// поэтому мы пока остановимся на одном единственном типе частиц с точечной (шаровой) симметрией
//////////////////////////////////////////////////////////////////////////////

class ParticleData {
public:
    Vec3<double> r;
    Vec3<double> v;
    Vec3<double> a;
};

//////////////////////////////////////////////////////////////////////////////
// ParticleType
// нужен чтобы хранить параметры общие для групп частиц
//////////////////////////////////////////////////////////////////////////////

class ParticleType {
public:
};

class ParticleTypePointR : public ParticleType {
public:
    double q;
    double m;
    double qpm;
};

class ParticleTypeSphereR : public ParticleType {
public:
    double q;
    double m;
    double qpm;
    double radius;
};

//////////////////////////////////////////////////////////////////////////////
// Particle - in time
//////////////////////////////////////////////////////////////////////////////

class Particle {
public:
    std::vector<ParticleData> p;
    int nmax;
    ParticleType *type;
};